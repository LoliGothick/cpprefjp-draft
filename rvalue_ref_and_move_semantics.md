#右辺値参照・ムーブセマンティクス
* cpp11[meta cpp]

<!-- `[meta cpp]`は、機能が追加・非推奨・削除されたバージョンを表すメタ情報。改行して複数指定ができる。 -->
<!--    `cpp11[meta cpp]` : C++11で追加された機能 -->
<!--    `cpp14[meta cpp]` : C++14で追加された機能 -->
<!--    `cpp11deprecated[meta cpp]` : C++11で非推奨になった機能 -->
<!--    `cpp14deprecated[meta cpp]` : C++14で非推奨になった機能 -->
<!--    `cpp14removed[meta cpp]` : C++14で削除された機能 -->

##概要
ムーブセマンティクスはコピーコストの削減を主な目的としており、また所有権の移動を実現する。  
右辺値参照はムーブされたオブジェクトを参照するための言語機能である。


###右辺値参照

右辺値参照とは右辺値を参照できる参照である。  
左辺値参照はアンパサンドを1つ用いるのに対して、右辺値参照はアンパサンドを2つ用いる文法になっている。  
左辺値は左辺値参照で参照でき、右辺値は右辺値参照で参照できる。  
右辺値を左辺値参照で参照することはできず、左辺値を右辺値参照で参照することもできない。  

この記法が導入される前から存在していたアンパサンド一つの参照型は、C++11では左辺値参照とよばれているものである。
C++11以前は右辺値の参照はconstな左辺値参照を用いていた。  
constな左辺値参照は右辺値を参照できるのである。  


```cpp
int main()
{
    int x = 0;

    // lvalue reference
    int& lvalue_ref_1 = x;              // OK
    // int& lvalue_ref_2 = 0;           // Error 右辺値を左辺値参照で参照している

    // rvalue reference
    // int&& rvalue_ref_1 = x;          // Error 左辺値を右辺値参照で参照している
    int&& rvalue_ref_2 = 0;             // OK
    int const& const_lvalue_ref = 0;    // OK constな左辺値参照は右辺値を参照できる
}
```

###右辺値（Rvalues）と左辺値（Lvalues）について

誤解を恐れずに言えば、右辺値とは一時的なオブジェクトである。  
また、左辺値とは明示的に実態のある名前付きオブジェクトである。  

```cpp
struct Foo{} ;
int f() { return 0 ; }

int main()
{
    int i = 0;

    i;      // 名前付きオブジェクトは左辺値
    0;      // リテラル値は右辺値

    Foo x ;

    x;      // 名前付きオブジェクトは左辺値
    Foo();  // コンストラクタの戻り値は右辺値

    f();    // 関数の戻り値は右辺値
}
```


###ムーブ
あるオブジェクトをムーブしたいときには、
`std::move`を使うことができる。
ムーブされた変数は右辺値となり、それ以降使えなくなる。  

```cpp
#include <memory>
int main()
{
    int x = 0;

    // move
    int&& rvalue_ref = std::move(x);     // これ以降xを使える保証はない
}
```

###ムーブセマンティクス

ムーブが必要とされる場面として、コピーに高いコストがかかる場合をあげる。  
コピーコンストラクタ、コピー代入に高いコストがかかる以下のクラスで説明する。

```cpp
#include <memory>
class large_class
{
private:
    char* ptr ;
public:
    large_class() {
      ptr = new char[1000];
      // バッファに対して、時間のかかる書き込みを実行
    }
    // コピーコンストラクタ
    large_class( const large_class& r ) {
        ptr = new char[1000] ;
        std::copy( &ptr[0], &ptr[1000], &r.ptr[0] );
    }
    // デストラクタ
    ~large_class() {
        delete[] ptr;
    }
};

int main()
{
    large_class x{};
    
    // とても時間がかかる
    large_class y(x);
}
```

コピーには時間がかかる。  
コピーをポインタの挿げ替えにしてしまえば、定数時間で処理が終わる。  
そうすると元のオブジェクトが参照できなくなる。  
しかし、そうなっても良い場合がある。  
一時変数からオブジェクトを作る場合などである。  

```cpp
    // 一時変数
    large_class tmp{};
    
    large_class x(tmp);
    // これ以降tmpは使わない
```

もう使わない変数とそうでない変数を区別する必要がある。  
そこで登場するのが右辺値と右辺値参照である。  
右辺値であるということが、変数をムーブしてもよいという意味となる。  

###ムーブコンストラクタ・ムーブ代入演算子

さきほどの`large_class`にムーブコンストラクタ（右辺値参照を引数とするコンストラクタ）を追加する。  
同様にムーブ代入演算子（右辺値参照を引数とする代入演算子）を追加する。  


```cpp
    // ムーブコンストラクタ
    large_class(large_class&& r)
    {
        // ポインタの挿げ替え
        ptr = r.ptr;
        // 元のオブジェクトはnullptrに
        r.ptr = nullptr;
    }
 ```

一時変数を`std::move`すると右辺値となり、ムーブコンストラクタが呼ばれる。  

```cpp
int main(){
    large_class tmp{};
    
    large_class x(std::move(tmp));   
}
```

標準ライブラリで提供されるクラスは（mutexなどを除き）ほとんどは、このようなムーブコンストラクタを用意している。  


###ユニヴァーサル参照
テンプレート変数や`auto`に`&&`をつけた場合には、通常の右辺値参照とは異なる動作をする。

```cpp
template <typename T>
void f(T&& x){};
```

とした場合、`f()`に渡された実引数が左辺値の場合には左辺値参照となり、右辺値の場合は右辺値参照となる。  
これは、次で説明する完全転送に関わる。

###完全転送（Perfect Forwarding）

ある関数内で引数を別の関数に渡したいことがある。  
引数を右辺値参照した場合はムーブして渡すことが自然である。  
しかし、引数をユニヴァーサル参照で宣言した場合安易にムーブできないい。  
引数は右辺値参照の場合と左辺値参照の場合両方があり得るからである。  
左辺値地参照の場合はムーブせず、右辺値参照の場合はムーブして渡す機能が必要となる。  
そのような機能として、`std::forward`が用意されている。  


```cpp
template <typename T>
void f(T&& a)
{
    // 実引数が右辺値参照型の場合のみムーブされる
　　g( std::forward<T>(a) ) ;
}
```


###所有権の移動
クラスによっては、ムーブは所有権の移動を表す。
例を挙げると、`std::unique_ptr`がそれに当たる。
`std::unique_ptr`はあるオブジェクトの唯一の所有権を持つことを表すスマートポインタである。
所有権は唯一であるので、コピーが禁止されている。
しかし、別の変数にムーブ代入することはできる。

```cpp
#include <memory>
int main()
{
    std::unique_ptr<int> p = std::make_unique<int>( 1 );
    
    // 所有権はqに移り
    // pはnullptrになる
    std::unique_ptr<int> q = std::move(p);
}
```

他には、`iostream`も所有権の移動に対応している。


##仕様

###式の分類
右辺値と左辺値は、明快な基準によって2つに分けることが難しい。  
厳密な分類は以下のようになっている。  

`expression`は、  
`glvalue`と`rvalue`に分類できる。  
`glvalue`と`rvalue`は、  
`lvalue`と`xvalue`と`prvalue`に分類できる。


__lvalue__  
lvalueは関数もしくはオブジェクトを指す  

名前付きの変数が指し示すオブジェクトや。  
ポインタを通してアクセスできるオブジェクトが該当する。  
戻り値の型が左辺値参照型の関数の戻り値などもこれにあたる。  

__xvalue__  
xvalueも、オブジェクトを指す。  

xvalueのオブジェクトはその寿命が近いか、寿命に関心がないことを表現するために使われる。    
xvalueは、一部の式の結果や、rvalueリファレンスへの明示的なキャストなどが該当する。  
  
xvalueの名前の由来は、eXpiring value(期限切れ値)。  
xvalueは寿命が近いか、寿命に関心がなく、値を消してしまって問題がないという意味。  
オブジェクトがxvalueならば、ムーブしても問題はないことを表現するために使われる。  
__glvalue__  
glvalueは、lvalueとxvalueの総称。  

glvalueの名前の由来は、generalized lvalue(一般化されたlvalue)。  

__rvalue__  
rvalueは、prvalueとxvalueの総称。  

xvalueの他には、一時オブジェクトや、リテラル値(10, 3.14, trueなど)や、特定のオブジェクトに関連付けられていない値などが該当する。  

__prvalue__  
prvalue(pure rvalue)は、rvalueのうちxvalueではないものである。  

一時オブジェクトやリテラル値や、オブジェクトに関連付けされていない値など。  
ほかには、関数の戻り値で、型がリファレンスではないものや、  
enumの列挙子などもこれにあたる。  

##例



##この機能が必要になった背景・経緯
ムーブセマンティクスはあるオブジェクトから他のオブジェクトにリソースを明け渡すということである。  
これは、C++11以前でもNRVO（特定の文脈でのコンストラクタの省略）や、
C++11で非推奨となった`std::auto_ptr`で実現されていた。  
しかし、NRVOがいつでも機能するわけではなかった。  
また、`std::auto_ptr`にはコピーと同じ文法でムーブしていることなど、問題が多かった。  
そのため、コピーと区別でき、統一的にムーブを表す文法が言語機能として必要とされた。



##関連項目
[unique_ptr](https://cpprefjp.github.io/reference/memory/unique_ptr.html)  


##参照
[N1377](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm) 必要になった経緯について  
