#右辺値参照・ムーブセマンティクス
* cpp11[meta cpp]

<!-- `[meta cpp]`は、機能が追加・非推奨・削除されたバージョンを表すメタ情報。改行して複数指定ができる。 -->
<!--    `cpp11[meta cpp]` : C++11で追加された機能 -->
<!--    `cpp14[meta cpp]` : C++14で追加された機能 -->
<!--    `cpp11deprecated[meta cpp]` : C++11で非推奨になった機能 -->
<!--    `cpp14deprecated[meta cpp]` : C++14で非推奨になった機能 -->
<!--    `cpp14removed[meta cpp]` : C++14で削除された機能 -->

##概要
ムーブセマンティクスとは、
所有権の移動および、コピーコストを抑えることを主な目的とした概念の名前である。  

右辺値参照はムーブされたオブジェクトを参照するための言語機能である。

###右辺値（Rvalues）と左辺値（Lvalues）について

誤解を恐れずに言えば、右辺値とは一時的なオブジェクトである。  
また、左辺値とは明示的に実態のある名前付きオブジェクトである。  


###右辺値参照について

右辺値参照とは右辺値を参照できる参照である。  
左辺値参照はアンパサンドを1つ用いるのに対して、右辺値参照はアンパサンドを2つ用いる文法になっている。  
左辺値は左辺値参照で参照でき、右辺値は右辺値参照で参照できる。  
右辺値を左辺値参照で参照することはできず、左辺値を右辺値参照で参照することもできない。  


###ムーブ
あるオブジェクトをムーブ（所有権を移動）したいときには、
`std::move`を使うことができる。

###所有権の移動
クラスによっては、ムーブは所有権の移動を表す。
例を挙げると、`std::unique_ptr`がそれに当たる。
`std::unique_ptr`はあるオブジェクトの唯一の所有権を持つことを表すスマートポインタである。
所有権は唯一であるので、コピーが禁止されている。
しかし、別の変数にムーブ代入することはできる。



##仕様

###式の分類
右辺値と左辺値は、明快な基準によって2つに分けることが難しい。  
厳密な分類は以下のようになっている。  

`expression`は、  
`glvalue`と`rvalue`に分類できる。  
`glvalue`と`rvalue`は、  
`lvalue`と`xvalue`と`prvalue`に分類できる。


__lvalue__  
lvalueは関数もしくはオブジェクトを指す  

名前付きの変数が指し示すオブジェクトや。  
ポインタを通してアクセスできるオブジェクトが該当する。  
戻り値の型が左辺値参照型の関数の戻り値などもこれにあたる。  

__xvalue__  
xvalueも、オブジェクトを指す。  

xvalueのオブジェクトはその寿命が近いか、寿命に関心がないことを表現するために使われる。    
xvalueは、一部の式の結果や、rvalueリファレンスへの明示的なキャストなどが該当する。  
  
xvalueの名前の由来は、eXpiring value(期限切れ値)。  
xvalueは寿命が近いか、寿命に関心がなく、値を消してしまって問題がないという意味。  
オブジェクトがxvalueならば、ムーブしても問題はないことを表現するために使われる。  
__glvalue__  
glvalueは、lvalueとxvalueの総称。  

glvalueの名前の由来は、generalized lvalue(一般化されたlvalue)。  

__rvalue__  
rvalueは、prvalueとxvalueの総称。  

xvalueの他には、一時オブジェクトや、リテラル値(10, 3.14, trueなど)や、特定のオブジェクトに関連付けられていない値などが該当する。  

__prvalue__  
prvalue(pure rvalue)は、rvalueのうちxvalueではないものである。  

一時オブジェクトやリテラル値や、オブジェクトに関連付けされていない値など。  
ほかには、関数の戻り値で、型がリファレンスではないものや、  
enumの列挙子などもこれにあたる。  

##例

###右辺値と左辺値

```cpp
struct Foo{} ;
int f() { return 0 ; }

int main()
{
    int i = 0;

    i;      // 名前付きオブジェクトはlvalue
    0;      // リテラル値はrvalue

    Foo x ;

    x;      // 名前付きオブジェクトはlvalue
    Foo();  // コンストラクタの戻り値はrvalue

    f();    // 関数の戻り値はrvalue
}
```

###出力
```
0
```


###右辺値参照

```cpp
int main()
{
    int x = 0;

    // lvalue reference
    int& lvalue_ref_1 = x;      // OK
    // int& lvalue_ref_2 = 0;   // 右辺値を左辺値参照で参照している Error

    // rvalue reference
    // int&& rvalue_ref_1 = x;  // 左辺値を右辺値参照で参照している Error
    int&& rvalue_ref_2 = 0;     // OK
}
```

###出力
```
0
```

###ムーブ

```cpp
#include <memory>
int main()
{
    int x = 0;

    // move
    int&& rvalue_ref = std::move(x);     // これ以降xを使える保証はない
}
```

###出力
```
0
```

###所有権の移動

```cpp
#include <memory>
int main()
{
    auto p = std::make_unique<int>( 1 );
    
    // 所有権はqに移り
    // pはnullptrになる
    auto q = std::move(p);
}
```

###出力
```
0
```



##この機能が必要になった背景・経緯
ムーブセマンティクスはあるオブジェクトから他のオブジェクトにリソースを明け渡すということである。  
これは、C++11以前でもNRVO（特定の文脈でのコンストラクタの省略）や、
C++11で非推奨となった`std::auto_ptr`で実現されていた。  
しかし、NRVOがいつでも機能するわけではなかった。  
また、`std::auto_ptr`にはコピーと同じ文法でムーブしていることなど、問題が多かった。  
そのため、コピーと区別でき、統一的にムーブを表す文法が言語機能として必要とされた。



##関連項目
[unique_ptr](https://cpprefjp.github.io/reference/memory/unique_ptr.html)  


##参照
[N1377](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm) 必要になった経緯について  
